#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../config/environment"
require "telegram/bot"

token_raw = ENV["TELEGRAM_BOT_TOKEN"].to_s
# Acepta tanto el token puro como strings donde el usuario pegó "HTTP API:\n<token>"
token = token_raw.strip[/\d+:[A-Za-z0-9_-]+/]
abort "Falta TELEGRAM_BOT_TOKEN (pegá solo el token tipo 123:ABC...)" if token.blank?

def ensure_user(message)
  telegram_user_id = message.from&.id&.to_s
  chat_id = message.chat&.id&.to_s
  raise "No pude leer telegram_user_id/chat_id" if telegram_user_id.blank? || chat_id.blank?

  user = User.find_or_create_by!(telegram_user_id: telegram_user_id)
  user.update!(telegram_chat_id: chat_id) if user.telegram_chat_id != chat_id
  user
end

def format_ars(amount_cents)
  pesos = amount_cents.to_i / 100.0
  format("$%.2f ARS", pesos)
end

Telegram::Bot::Client.run(token) do |bot|
  bot.listen do |message|
    case message
    when Telegram::Bot::Types::Message
      next if message.text.blank? && message.contact.blank?

      user = ensure_user(message)

      if message.text&.start_with?("/start")
        bot.api.send_message(
          chat_id: message.chat.id,
          text: "Listo. Mandame gastos tipo: \"hamburguesa 8500\" o \"pago luz 23000\".\n\nSi mandás sin monto, te lo pregunto.\n\nSi querés asociar teléfono, mandá /phone y compartís tu contacto."
        )
        next
      end

      if message.text&.start_with?("/help")
        bot.api.send_message(
          chat_id: message.chat.id,
          text: "Ejemplos:\n- hamburguesa 8500\n- pago internet 24000\n- kiosko gaseosa 2500\n\nSi mandás sin monto, te lo pregunto."
        )
        next
      end

      if message.text&.start_with?("/phone")
        kb = Telegram::Bot::Types::ReplyKeyboardMarkup.new(
          keyboard: [[Telegram::Bot::Types::KeyboardButton.new(text: "Compartir mi contacto", request_contact: true)]],
          resize_keyboard: true,
          one_time_keyboard: true
        )
        bot.api.send_message(chat_id: message.chat.id, text: "Tocá para compartir tu número (opcional).", reply_markup: kb)
        next
      end

      if message.contact
        # Seguridad: aceptar solo el contacto propio (cuando Telegram provee user_id).
        if message.contact.user_id.present? && message.contact.user_id.to_s != message.from&.id&.to_s
          bot.api.send_message(chat_id: message.chat.id, text: "Por seguridad, solo puedo guardar tu propio contacto.")
          next
        end

        phone = message.contact.phone_number.to_s
        phone = phone.start_with?("+") ? phone : "+#{phone}"
        user.update!(phone_e164: phone)
        bot.api.send_message(chat_id: message.chat.id, text: "OK. Teléfono asociado: #{phone}")
        next
      end

      text = message.text.to_s.strip

      # Si hay un borrador esperando monto, aceptar número como respuesta.
      draft = user.draft_expenses.order(created_at: :desc).find_by(state: "awaiting_amount")
      if draft && text.match?(/\d/)
        amount_cents, _ = ExpenseTextParser.parse(text, currency: user.currency)
        if amount_cents.nil?
          bot.api.send_message(chat_id: message.chat.id, text: "No entendí el monto. Probá: 8500 o 23.000,50")
          next
        end

        description = draft.extracted["description"].presence || draft.raw_text
        cat = ExpenseClassifier.new.classify(description)

        expense = user.expenses.create!(
          amount_cents: amount_cents,
          currency: user.currency,
          description: description,
          category: cat.category,
          subcategory: cat.subcategory,
          raw_text: draft.raw_text,
          llm_provider: ENV["LLM_PROVIDER"],
          llm_model: ENV["OPENAI_MODEL"],
          llm_confidence: cat.confidence,
          metadata: { flow: "draft_amount" }
        )

        draft.destroy!
        bot.api.send_message(
          chat_id: message.chat.id,
          text: "Registrado: #{format_ars(expense.amount_cents)} — #{[expense.category, expense.subcategory].compact.join(" / ")} — #{expense.description}"
        )
        next
      end

      amount_cents, description = ExpenseTextParser.parse(text, currency: user.currency)
      if amount_cents.nil?
        user.draft_expenses.create!(raw_text: text, extracted: { "description" => description }, state: "awaiting_amount")
        bot.api.send_message(chat_id: message.chat.id, text: "¿Cuánto fue el monto en ARS para: \"#{description}\"?")
        next
      end

      cat = ExpenseClassifier.new.classify(description)
      expense = user.expenses.create!(
        amount_cents: amount_cents,
        currency: user.currency,
        description: description,
        category: cat.category,
        subcategory: cat.subcategory,
        spent_at: Time.zone.now,
        raw_text: text,
        llm_provider: ENV["LLM_PROVIDER"],
        llm_model: ENV["OPENAI_MODEL"],
        llm_confidence: cat.confidence,
        metadata: { flow: "direct" }
      )

      bot.api.send_message(
        chat_id: message.chat.id,
        text: "Registrado: #{format_ars(expense.amount_cents)} — #{[expense.category, expense.subcategory].compact.join(" / ")} — #{expense.description}"
      )
    end
  rescue StandardError => e
    bot.api.send_message(chat_id: message.chat.id, text: "Error: #{e.class} - #{e.message}") rescue nil
  end
end


